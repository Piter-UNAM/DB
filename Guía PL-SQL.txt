Guía de PL/SQL

Creación de base de datos para trabajar los futuros ejemplos:

CREATE TABLE estudiantes(
id NUMBER(5) PRIMARY KEY,
nombre CHAR(20),
apellido CHAR(20),
especialidad CHAR(20),
creditos NUMBER
);

CREATE TABLE aulas(
idaula NUMBER(5) PRIMARY KEY,
edificio CHAR(15),
numeroaula NUMBER,
numeroasientos NUMBER,
descripcionaula CHAR(50)
);

CREATE TABLE especialidades(
especialidad CHAR(30),
totalcreditos NUMBER,
totalestudiantes NUMBER
);

CREATE TABLE cursos(
departamento CHAR(3),
ncurso NUMBER,
descripcioncurso CHAR(200),
cupoestudiantes NUMBER,
nestudiantes NUMBER,
ncreditos NUMBER,
idaula NUMBER,
CONSTRAINT cursos_departamento_curso PRIMARY KEY(departamento, ncurso),
CONSTRAINT cursos_idaula FOREIGN KEY(idaula) REFERENCES aulas(idaula)
);

CREATE TABLE estudios(
idestudiante NUMBER NOT NULL,
departamento CHAR(3) NOT NULL,
Ncurso NUMBER NOT NULL,
grado CHAR(1),
CONSTRAINT estudios_grado CHECK(grado IN('A','B','C','D','E')),
CONSTRAINT estudios_idestudiante FOREIGN KEY (idestudiante) REFERENCES estudiantes(id),
CONSTRAINT estudios_departamento_ncurso FOREIGN KEY (departamento, ncurso) REFERENCES cursos (departamento, ncurso)
);

CREATE TABLE clientes(
Num_clie integer not null PRIMARY KEY,
Empresa char(20) not null,
Repclie integer,
Limite_credito numeric
);

CREATE TABLE repventas(
Num_empl integer not null PRIMARY KEY,
Nombre char(15) not null,
Edad integer,
Oficina_rep integer,
Titulo char(10),
Contrato date not null,
Director integer,
Cuota numeric,
Ventas numeric not null
);

CREATE TABLE oficinas(
Oficina integer not null PRIMARY KEY,
Ciudad char(15) not null,
Region char(10) not null,
Dir integer REFERENCES repventas (Num_empl),
Objetivo number,
Ventas number not null
);

CREATE TABLE productos(
Id_fab char(3) not null,
Id_producto char(5) not null,
Descripcion char(20) not null,
Precio number not null,
Existencias integer not null,
CONSTRAINT productos_Id_fab_Id_producto 
PRIMARY KEY (Id_fab, Id_producto)
);

CREATE TABLE pedidos (
Num_pedido integer not null PRIMARY KEY,
Fecha date not null,
Clie integer not null REFERENCES clientes (Num_clie),
Rep integer REFERENCES repventas (Num_empl),
Fab char(3) not null,
Producto char(5) not null,
Cant integer not null,
Importe number not null
);

CREATE TABLE dept( /*departamentos*/
deptno NUMBER(2) CONSTRAINT pk_dept PRIMARY KEY, /*numero de departamento*/
dname VARCHAR2(14), /*nombre del departamento*/
loc VARCHAR2(12) /*localidad del departamento*/
);

CREATE TABLE emp( /*empleados*/
empno NUMBER(4) CONSTRAINT pk_emp PRIMARY KEY, /*numerode empleado*/
ename VARCHAR2(10), /*nombre del empleado*/
job VARCHAR2(9), /*trabajo del empleado*/
mgr NUMBER(4), /*codigo del oficio*/
hiredate DATE, /*fecha de contrato*/
sal NUMBER(7,2), /*salario*/
comm NUMBER(7,2), /*comision*/
deptno NUMBER(2) CONSTRAINT fk_deptno REFERENCES dept
);

CREATE TABLE bonus( /*bonificaciones a empleados*/
ename VARCHAR2(10), /*nombre del empleado*/
job VARCHAR2(9), /*trabajo del empleado*/
sal NUMBER, /*salario del empleado*/
comm NUMBER
);
CREATE TABLE salgrade( /*nivel salarial de empleados*/
grade NUMBER, /*nivel de salario*/
losal NUMBER, /*salario máximo*/
hisal NUMBER /*salario mínimo*/
);

Datos para insertar en las distintas tablas anteriormente creadas

INSERT INTO estudiantes VALUES(1,'Scott','Smith','Computer Science',0);
INSERT INTO estudiantes VALUES(2,'Margaret','Mason','History',0);
INSERT INTO estudiantes VALUES(3,'Joanne','Junebug','Computer Science',0);
INSERT INTO estudiantes VALUES(4,'Manish','Murgratroid','Economics',0);
INSERT INTO estudiantes VALUES(5,'Patrick','Poll','History',0);
INSERT INTO estudiantes VALUES(6,'Timothy','Taller','Hhistory',0);
INSERT INTO estudiantes VALUES(7,'Barbara','Blues',Economics',0);
INSERT INTO estudiantes VALUES(8,'David','Dinsmore','Music',0);
INSERT INTO estudiantes VALUES(9,'Ester','Elegant','Nutrition',0);
INSERT INTO estudiantes VALUES(10,'Rose','Riznit','Music',0);
INSERT INTO estudiantes VALUES(11,'Rita','Razmataz','Nutrition',0);

INSERT INTO aulas VALUES(99999,'Building 7',310,1000,'Large Lecture Hall');
INSERT INTO aulas VALUES(99998,'Building 6',101,500,'Small Lecture Hall');
INSERT INTO aulas VALUES(99997,'Building 6',150,50,'Discussion Room A');
INSERT INTO aulas VALUES(99996,'Building 6',160,50,'Discussion Room B');
INSERT INTO aulas VALUES(99995,'Building 6',170,50,'Discussion Room C');
INSERT INTO aulas VALUES(99994,'Music Building',100,10,'Music Practice Room');
INSERT INTO aulas VALUES(99993,'Music Building',200,1000,'Concert Room');
INSERT INTO aulas VALUES(99992,'Building 7',300,75,'Discussion Room D');
INSERT INTO aulas VALUES(99991,'Building 7',310,50,'Discussion Room E');

INSERT INTO cursos VALUES('HIS',101,'History 101',30,0,4,99999);
INSERT INTO cursos VALUES('HIS',301,'History 301',30,0,4,99995);
INSERT INTO cursos VALUES('CS',101,'Computer Science 101',50,0,4,99998);
INSERT INTO cursos VALUES('ECN',203,'Economics 203',15,0,3,99997);
INSERT INTO cursos VALUES('CS',102,'Computer Science 102',35,0,4,99996);
INSERT INTO cursos VALUES('MUS',410,'Music 410',5,0,3,99994);
INSERT INTO cursos VALUES('ECN',101,'Economics 101',50,0,4,99992);
INSERT INTO cursos VALUES('NUT',307,'Nutrition 307',20,0,4,99991);

INSERT INTO estudios VALUES(1,'CS',102,'A');
INSERT INTO estudios VALUES(3,'CS',102,'B');
INSERT INTO estudios VALUES(4,'CS',102,'C');
INSERT INTO estudios VALUES(1,'HIS',101,'A');
INSERT INTO estudios VALUES(2,'HIS',101,'B');
INSERT INTO estudios VALUES(3,'HIS',101,'B');
INSERT INTO estudios VALUES(4,'HIS',101,'A');
INSERT INTO estudios VALUES(5,'HIS',101,'C');
INSERT INTO estudios VALUES(6,'HIS',101,'C');
INSERT INTO estudios VALUES(7,'HIS',101,'E');
INSERT INTO estudios VALUES(8,'HIS',101,'B');
INSERT INTO estudios VALUES(9,'HIS',101,'A');
INSERT INTO estudios VALUES(10,'HIS',101,'D');
INSERT INTO estudios VALUES(11,'HIS',101,'A');
INSERT INTO estudios VALUES(9,'NUT',307,'A');
INSERT INTO estudios VALUES(11,'NUT',307,'A');
INSERT INTO estudios VALUES(10,'MUS',410,'B');
INSERT INTO estudios VALUES(7,'MUS',410,'E');

INSERT INTO clientes VALUES (2101,'Jones Mfg.',106,65000);
INSERT INTO clientes VALUES (2102,'First. Corp.',101,65000);
INSERT INTO clientes VALUES (2103,'Acme Mfg.',105,50000);
INSERT INTO clientes VALUES (2105,'AAA Investments',101,45000);
INSERT INTO clientes VALUES (2106,'Fred Lewis Crop.',102,65000);
INSERT INTO clientes VALUES (2107,'Ace International',110,35000);
INSERT INTO clientes VALUES (2108,'Holm Landis',109,55000);
INSERT INTO clientes VALUES (2109,'Chen associates',103,25000);
INSERT INTO clientes VALUES (2111,'JCP Inc.',103,50000);
INSERT INTO clientes VALUES (2112,'Zetacorp',108,50000);
INSERT INTO clientes VALUES (2113,'Ian Schmidt',104,20000);
INSERT INTO clientes VALUES (2114,'Orion Corp',102,20000);
INSERT INTO clientes VALUES (2115,'Smithson Corp',101,20000);
INSERT INTO clientes VALUES (2117,'J.P. Sinclair',106,35000);
INSERT INTO clientes VALUES (2118,'Midwest Systems',108,60000);
INSERT INTO clientes VALUES (2119,'Solomon INC. ',109,25000);
INSERT INTO clientes VALUES (2120,'Rico Enterprises',102,50000);
INSERT INTO clientes VALUES (2121,'QMA Assoc',103,45000);
INSERT INTO clientes VALUES (2122,'Three-Way Lines',105,30000);
INSERT INTO clientes VALUES (2123,'Carter Sons',102,40000);
INSERT INTO clientes VALUES (2124,'Peter Brothers',107,40000);

INSERT INTO repventas VALUES(101,'Dan Roberts',45,12,'Rep Ventas','20-10-1986',104,300000,305673);
INSERT INTO repventas VALUES(102,'Sue Smith',48,21,'Rep Ventas','12-12-1986',108,350000,474050);
INSERT INTO repventas VALUES(103,'Paul Cruz',29,12,'Rep Ventas','01-04-1987',104,275000,286775);
INSERT INTO repventas VALUES(104,'Bob Smith',33,12,'Dir Ventas','19-05-1987',106,200000,142594);
INSERT INTO repventas VALUES(105,'Bill Adams',37,13,'Rep Ventas','12-02-1988',104,350000,367911);
INSERT INTO repventas VALUES(106,'Sam Clark',52,11,'VP Ventas','14-06-1988',null,275000,299912);
INSERT INTO repventas VALUES(107,'Nancy Angelli',49,22,'Rep Ventas','14-11-1988',108,300000,186042);
INSERT INTO repventas VALUES(108,'Larry Fitch',62,21,'Dir Ventas','12-10-1989',106,350000,361865);
INSERT INTO repventas VALUES(109,'Mary Jones',31,11,'Rep Ventas','12-10-1999',106,300000,392725);
INSERT INTO repventas VALUES(110,'Tom Snyde',41,null,'Rep Ventas','14-01-1990',101,null,75985);

INSERT INTO oficinas VALUES (11,'New York','Este',106,575000,692637);
INSERT INTO oficinas VALUES (12,'Chicago','Este',104,800000,735042);
INSERT INTO oficinas VALUES (13,'Atlanta','Este',105,350000,367911);
INSERT INTO oficinas VALUES (21,'Los Ángeles','Oeste',108,725000,835915);
INSERT INTO oficinas VALUES (22,'Denver','Oeste',108,300000,186042);

INSERT INTO productos VALUES ('ACI','41001','Articulo Tipo 1', 55, 277);
INSERT INTO productos VALUES ('ACI','41002','Articulo Tipo 2', 76, 167);
INSERT INTO productos VALUES ('ACI','41003','Articulo Tipo 3', 107, 207);
INSERT INTO productos VALUES ('ACI','41004','Articulo Tipo 4', 117, 139);
INSERT INTO productos VALUES ('ACI','4100X','Ajustador', 35, 37);
INSERT INTO productos VALUES ('ACI','4100Y','Extractor', 2.750, 25);
INSERT INTO productos VALUES ('ACI','4100Z','Montador', 2.500, 28);
INSERT INTO productos VALUES ('BIC','41003','Manivela', 652, 3);
INSERT INTO productos VALUES ('BIC','41089','Retn', 225, 78);
INSERT INTO productos VALUES ('BIC','41672','Plate', 180, 0);
INSERT INTO productos VALUES ('FEA','112','Cubierta', 148, 115);
INSERT INTO productos VALUES ('FEA','114','Bancada Motor', 243, 15);
INSERT INTO productos VALUES ('IMM','773C','Riostra 1/2 Tm', 975, 28);
INSERT INTO productos VALUES ('IMM','775C','Riostra 1-Tm', 1.425, 5);
INSERT INTO productos VALUES ('IMM','779C','Riostra 2-Tm', 1.875, 9);
INSERT INTO productos VALUES ('IMM','878H','Soporte Riostra', 54, 223);
INSERT INTO productos VALUES ('IMM','887P','Perno Riostra', 250, 24);
INSERT INTO productos VALUES ('IMM','887X','Retenedor Riostra', 475, 32);
INSERT INTO productos VALUES ('QSA','XK47','Reductor', 355, 38);

INSERT INTO productos VALUES ('QSA','XK48','Reductor', 134, 203);
INSERT INTO productos VALUES ('QSA','XK48A','Reductor', 117, 37);
INSERT INTO productos VALUES ('REI','2A44G','Pasador Bisagra', 350, 14);
INSERT INTO productos VALUES ('REI','2A44L','Bisagra Izqda', 4.500, 12);
INSERT INTO productos VALUES ('REI','2A44R','Bisagra Dcha', 4.500, 12);
INSERT INTO productos VALUES ('REI','2A45C','V Stago Trinquete', 79, 210);

INSERT INTO pedidos VALUES(110036,'30-01-1990',2107,110,'ACI','4100Z',9,22500);
INSERT INTO pedidos VALUES(112961,'17-12-1989',2117,106,'REI','2A44L',7,31500);
INSERT INTO pedidos VALUES(112963,'17-12-1989',2103,105,'ACI','41004',28,3276);
INSERT INTO pedidos VALUES(112968,'12-10-1989',2102,101,'ACI','41004',34,3978);
INSERT INTO pedidos VALUES(112975,'12-10-1989',2111,103,'REI','2A44G',6,2100);
INSERT INTO pedidos VALUES(112979,'12-10-1989',2114,102,'ACI','4100Z',6,15000);
INSERT INTO pedidos VALUES(112983,'27-12-1989',2103,105,'ACI','41004',6,702);
INSERT INTO pedidos VALUES(112987,'31-12-1989',2103,105,'ACI','4100Y',11,27500);
INSERT INTO pedidos VALUES(112989,'04-01-1990',2101,106,'FEA','114',6,1458);
INSERT INTO pedidos VALUES(112992,'04-11-1989',2118,108,'ACI','41002',10,760);
INSERT INTO pedidos VALUES(112993,'04-01-1989',2106,102,'REI','2A45C',24,1896);
INSERT INTO pedidos VALUES(112997,'08-01-1990',2124,107,'BIC','41003',1,652);
INSERT INTO pedidos VALUES(113003,'25-01-1990',2108,109,'IMM','77AC',3,5625);
INSERT INTO pedidos VALUES(113007,'08-01-1990',2112,108,'IMM','773C',3,2925);
INSERT INTO pedidos VALUES(113012,'11-01-1990',2106,105,'ACI','41003',35,3745);
INSERT INTO pedidos VALUES(113013,'14-01-1990',2124,110,'BIC','41003',1,652);
INSERT INTO pedidos VALUES(113024,'20-01-1990',2108,101,'QSA','XK47',20,7100);
INSERT INTO pedidos VALUES(113027,'22-01-1990',2112,108,'ACI','41002',54,4104);
INSERT INTO pedidos VALUES(113034,'29-01-1990',2111,102,'REI','2A45C',8,632);
INSERT INTO pedidos VALUES(113042,'02-02-1990',2118,108,'REI','2A44R',5,22500);
INSERT INTO pedidos VALUES(113045,'02-02-1990',2114,108,'REI','2A44R',10,45000);
INSERT INTO pedidos VALUES(113048,'10-02-1990',2103,101,'IMM','779C',9,3750);
INSERT INTO pedidos VALUES(113049,'10-02-1990',2107,103,'QSA','XK47',9,2130);
INSERT INTO pedidos VALUES(113051,'10-02-1990',2118,109,'QSA','XK47',9,1420);
INSERT INTO pedidos VALUES(113055,'15-02-1990',2108,107,'ACI','4100X',9,150);
INSERT INTO pedidos VALUES(113057,'18-02-1990',2111,102,'ACI','4100X',9,600);
INSERT INTO pedidos VALUES(113058,'24-02-1990',2108,107,'FEA','112',9,1480);
INSERT INTO pedidos VALUES(113062,'24-02-1990',2124,110,'FEA','114',9,2430);
INSERT INTO pedidos VALUES(113065,'27-02-1990',2106,110,'QSA','XK47',9,2130);
INSERT INTO pedidos VALUES(113069,'02-04-1990',2109,110,'IMM','775C',9,31350);


/*---------------------------------------------------------------------------------------*/
Algunos comandos utiles para usar en PL/SQL
DESCRIBE : muestra los datos/variables que se estan manejando en una tabla

SQL> DESCRIBE CLIENTES;
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 NUM_CLIE                                  NOT NULL NUMBER(38)
 EMPRESA                                   NOT NULL CHAR(20)
 REPCLIE                                            NUMBER(38)
 LIMITE_CREDITO                                     NUMBER(38)

SELECT: obtiene los datos guardados en una tabla

SQL> select * from clientes;

  NUM_CLIE EMPRESA                 REPCLIE LIMITE_CREDITO
---------- -------------------- ---------- --------------
      2101 Jones Mfg.                  106          65000
      2102 First. Corp.                101          65000
      2103 Acme Mfg.                   105          50000
      2105 AAA Investments             101          45000
      2106 Fred Lewis Crop.            102          65000
      2107 Ace International           110          35000
      2108 Holm Landis                 109          55000
      2109 Chen associates             103          25000
      2111 JCP Inc.                    103          50000
      2112 Zetacorp                    108          50000
      2113 Ian Schmidt                 104          20000

SAVE: Guardar en fichero la sintaxis del comando actual (SAVE nombre_fichero)
GET: sirve para editar un nuevo fichero almacenado previamente ()
/*---------------------------------------------------------------------------------------*/

PL/SQL SE COMPONE DE LOS SIGUIENTES ELEMENTOS:
Bloques: Unidades básicas en la programación PL/SQL
Unidades léxicas: secuencias de caracteres permitidos en PL/SQL que componen los programas.
Tipos: elementos que pueden usarse en las columnas de la base de datos y definen la naturaleza de los datos permitidos en la base de datos y en el lenguaje PL/SQL. Los tipos de PL/SQL se definen en un paquete denominado STANDAR cuyos contenidos son accesibles desde cualquier bloque PL/SQL.
Expresiones y operadores: elementos que permiten unir las variables PL/SQL. Los operadores definen cómo se asignan los valores a las variables y cómo se manipulan dichos valores. Una expresión es una secuencia de variables y literales separados por operadores. El valor de una expresión se determina a partir de los valores de las variables y literales que la componen, y de la definición de los operadores.
Funciones: además de los tipos, el paquete STANDARD define las funciones predefinidas SQL y de conversión disponibles en PL/SQL.
Estructuras de control PL/SQL: permiten controlar el comportamiento del bloque a medida que este se ejecuta e incluyen las órdenes condicionales y los bucles. Las estructuras de control combinadas con las variables dotan a PL/SQL de poder y flexibilidad.
Registros: los registros de PL/SQL son similares a las estructuras del lenguaje C. Un registro proporciona un mecanismo para tratar con variables diferentes, pero relacionadas, como si fueran una unidad.
Tablas y matrices: las tablas PL/SQL se asemejan a las matrices del lenguaje C. Sintácticamente se las trata de la misma forma que a las matrices, aunque su implementación es distinta. Para poder declarar una tabla en PL/SQL es necesario primero definir su tipo y luego una variable de dicho tipo.
Cursores: dentro de PL/SQL la orden SELECT no debe devolver más de una fila, pero si es necesario que SELECT devuelva más de una fila hay que emplear un cursor para extraer individualmente cada fila.
Procedimientos: estructuras de bloques que pueden ser almacenados en la base de datos para ser ejecutados cuando sea necesario.
Paquetes: estructuras de bloques PL/SQL que proporcionan un mecanismo para extender en todo momento el propio lenguaje PL/SQL.
Disparadores: estructuras de bloques que se ejecutan de forma implícita cada vez que tiene lugar el suceso de disparo. Los disparadores no admiten argumentos.

/*---------------------------------------------------------------------------------------*/

Bloques PL/SQL
Los programas de PL/SQL están compuestos por bloques, que pueden estar situados uno detrás de otro(estructura secuencial) o pueden estar uno dentro de otro(estructura anidada). Por tanto, el bloque es la unidad básica en PL/SQL.

Los bloques tienen tres secciones diferenciadas:

-Sección declarativa: se sitúan en ella las variables, cursores y tipos usados por el bloque
-Sección ejecutables: se sitúan en ellas las órdenes SQL y las órdenes procedimentales que llevan a cabo el trabajo del bloque.
-Sección de excepciones: se sitúa en ella código que no se ejecuta a menos que ocurra un error. Por esta razón, la sección de excepciones suele llamase también sección de tratamiento de errores

La sintaxis de un programa PL/SQL será la siguiente:

DECLARE
/*Sección declarativa*/
BEGIN
/*Sección ejecutable*/
EXCEPTION
/*Sección de excepciones*/
NED;
/

Cuando se trabaja en el ambiente SQL*PLUS es necesario acabar los programas con una barra inclinada (/).
Las palabras DECLARE,BEGIN,EXCEPTION Y END delimitan cada una de las secciones.

La única sección indispensable en un bloque es la sección ejecutable, siendo las otras dos opcionales. Si falta la sección de excepciones, no aparecerá la palabra clave EXCEPTION, y el bloque terminará con la palabra clave END, seguida de un punto y coma. Por tanto, un programa mínimo, es decir, un programa PL/SQL con sólo la sección ejecutable, tiene la siguiente estructura:

BEGIN
/*Sección ejecutable*/
END;
/

/*---------------------------------------------------------------------------------------*/

Ejemplo de programa PL/SQL sin excepciones:

DECLARE
/*Declaración de las variables a utilizar*/
v_NuevaEspecialidad VARCHAR2(10):='History';
v_Nombre VARCHAR(10):='Scott';
v_Apellido VARCHAR(10):='Urman';
BEGIN
/*Actualización de la tabla ESTUDIANTES*/
UPDATE ESTUDIANTES
SET especialidad = v_NuevaEspecialidad
WHERE nombre = v_Apellido;
/*Comprobación de la existencia del registro antes de insertarlo*/
IF SQL%NOTFOUND THEN
INSERT INTO estudiantes (ID, nombre, apellido, especialidad)
VALUES (secuencia.NEXTVAL, v_Nombre, v_Apellido, v_NuevaEspecialidad);
END IF;
END;
/

/*---------------------------------------------------------------------------------------*/

Existen varios tipos de bloques
Los bloques anonimos: son aquellos bloques que se ejecutan una sola vez y que por regla general se construyen de manera dinámica.
Los bloques nominados: no son mas que bloques anónimos con una etiqueta que le da al bloque un nombre. Al igual que los bloques anónimos, se ejecutan una sola vez y suelen construirse de manera dinámica.
Subprogramas: Son procedimientos,paquetes y funciones almacenados en la base de datos. Estos blques suelen ejecutarse múltiples veces mediante una llamada al procedimiento, paquete o funcion que los constityuen.
Disparadores o triggers: son bloques nominados que se almacenan en la base de datos y que se ejecutan de manera implicita cada vez que tiene lugar un suceso de disparo. El suceso de disparo es una orden SQL del lenguaje DML de manipulación de datos que se ejecuta sobre una tabla de la base de datos.

Ejemplo de un bloque PL/SQL anónimo
DECLARE 
/*Declara las variables a utilizar en el bloque*/
v_Num1	NUMBER :=1;
V_Num2 NUMBER :=2;
v_String1 VARCHAR2(50) :="Hola!";
v_String2 VARCHAR2(50) :="-Mensaje en PL/SQL";
v_OutPutStr VARCHAR2(50);
BEGIN
/*Primero, insertamos dos filas en la tabla temporal, usando los valores de las variables.*/
INSERT INTO temporal (columnanumerica,columnacaracter) values (v_Num1,v_String1);
INSERT INTO temporal (columnanumerica,columnacaracter) values (v_Num2,v_String2);
/*Ahora consultamos la tabla temporal para ver las 2 filas recien insertadas, presentando en la pantalla utilizando el paquete DBMS_OUTPUT*/
SELECT columnacaracter INTO v_OutputStr FROM temporal WHERE columnanumerica= v_Num1;
DBMS_OUTPUT(v_OutputStr);
SELECT columnacaracter INTO v_OutputStr FROM temporal WHERE columnanumerica= v_Num2;
DBMS_OUTPUT(v_OutputStr);
END;
/
El bloque anónimo anterior puede convertirse en bloque nominado situando una etiqueta inmediatamente antes de la palabra clave DECLARE. La etiqueta también puede aparecer después de la palabra clave END tal y como se indica en el programa siguiente :
DECLARE 
/*Declara las variables a utilizar en el bloque*/
v_Num1	NUMBER :=1;
V_Num2 NUMBER :=2;
v_String1 VARCHAR2(50) :="Hola!";
v_String2 VARCHAR2(50) :="-Mensaje en PL/SQL";
v_OutPutStr VARCHAR2(50);
BEGIN
/*Primero, insertamos dos filas en la tabla temporal, usando los valores de las variables.*/
INSERT INTO temporal (columnanumerica,columnacaracter) values (v_Num1,v_String1);
INSERT INTO temporal (columnanumerica,columnacaracter) values (v_Num2,v_String2);
/*Ahora consultamos la tabla temporal para ver las 2 filas recien insertadas, presentando en la pantalla utilizando el paquete DBMS_OUTPUT*/
SELECT columnacaracter INTO v_OutputStr FROM temporal WHERE columnanumerica= v_Num1;
DBMS_OUTPUT(v_OutputStr);
SELECT columnacaracter INTO v_OutputStr FROM temporal WHERE columnanumerica= v_Num2;
DBMS_OUTPUT(v_OutputStr);
END "INSERTAR_EN_TEMPORAL";
/

El bloque nominado anterior puede convertirse en subprograma transformándolo en procedimiento almacenado mediante el cambio de la palabra clave DECLARE por las palabras clave CREATE OR REPLACE PROCEDURE y situando el nombre del procedimiento despues de la palabra clave END.

CREATE OR REPLACE PROCEDURE insertar_en_temporal AS 
/*Declara las variables a utilizar en el bloque*/
v_Num1	NUMBER :=1;
V_Num2 NUMBER :=2;
v_String1 VARCHAR2(50) :="Hola!";
v_String2 VARCHAR2(50) :="-Mensaje en PL/SQL";
v_OutPutStr VARCHAR2(50);
BEGIN
/*Primero, insertamos dos filas en la tabla temporal, usando los valores de las variables.*/
INSERT INTO temporal (columnanumerica,columnacaracter) values (v_Num1,v_String1);
INSERT INTO temporal (columnanumerica,columnacaracter) values (v_Num2,v_String2);
/*Ahora consultamos la tabla temporal para ver las 2 filas recien insertadas, presentando en la pantalla utilizando el paquete DBMS_OUTPUT*/
SELECT columnacaracter INTO v_OutputStr FROM temporal WHERE columnanumerica= v_Num1;
DBMS_OUTPUT(v_OutputStr);
SELECT columnacaracter INTO v_OutputStr FROM temporal WHERE columnanumerica= v_Num2;
DBMS_OUTPUT(v_OutputStr);
END insertar_en_temporal;
/

Ejemplo de estructura de disparador(Trigger):
CREATE OR REPLACE TRIGGER SoloPositivos
BEFORE INSERT OR UPDATE OF columnanumerica 
ON temporal
FOR EACH ROW
BEGIN
IF :new.columnanumerica<0 THEN
RAISE_APPLICATION_ERROR(-20100,'Por favor, inserte un valor positivo');
END IF;
END SoloPositivios;
/


/*---------------------------------------------------------------------------------------*/

Literales:
Numericos: Valores enteros o reales(opcionalmente precedidos por el signo más o menos)asignables a una variable de tipo NUMBER sin realizar conversiones.
Booleanos: TRUE, FALSE Y NULL
Caracter o cadena: uno o más caracteres delimitados por comillas simples y asignables a variables e tipo CHAR o VARCHAR2 sin realizar conversiones.

Comentarios:
--Para hacer comentarios en una solo linea
/*Para hacer comentarios multilinea*/

/*---------------------------------------------------------------------------------------*/

Estructuras de control

Las estructuras de control permiten controlas el comportamiento del bloque a medida que éste se ejecuta. Las más importantes son las estructuras condicionles y los bucles.

Estructuras condicionales
Se utilizan para la relación de acciones dependiendo del cumplimiento o no de determinadas condiciones.  Las estructuras condicionales más comunes son IF-THEN, IF-THEN-ELSE, IF-THEN-ELSIF Y CASE.

IF-THEN
Se trata de una estructura condicional en la que se ejecuta una secuencia de instrucciones si la condicion es cierta. Su sintaxis es la siguiente:

IF condicion THEN
Secuencia_de_instrucciones
END IF;

Ejemplo:
IF ventas > cota then
compute_bonus(empid);
UPDATE payroll SET pay= pay+bonus WHERE empno = emp_id;
END IF;
Se puede escribir todo en una sola fila
IF x > y THEN high := x; END IF;

IF-THEN-ELSE
Se trata de una estructura condicional en la que se ejecuta una primera secuencia de instrucciones si la condicion es cierta, y se ejecuta una segunda secuencia de instrucciones si la condicion es falsa. Su sintaxis es la siguiente:
IF condicion THEN 
secuencia_de_instrucciones;
ELSE
secuencia_de_instrucciones;
END IF;

Ejemplo:

IF trans_type = 'CR' THEN
UPDATE accounts SET balance = balance + credit WHERE ...
ELSE
UPDATE accounts SET balance = balance - debit WHERE ...
END IF;

Estas estructuras condicionales pueden anidarse tal y como se inidica en el siguiente ejemplo:

IF trans_type = 'CR' THEN
UPDATE accounts SET balance = balance + credit WHERE ...
ESLSE
	IF new_balance >= minimum_balance THEN
	UPDATE accounts SET balance = balance - debit WHERE ...
	ELSE
	RAISE insufficient_funds;
	END IF;
END IF;

IF-THEN-ELSIF
Estructura condicional que se utiliza para seleccionar una acción entre varias alternativas mutuamente excluyentes. Si la primera condición es falsa o nula, se pasa a testear la condición de la cláusula ELSIF comenzando una nueva estructura condicional IF-THEN-ELSE. Su sintaxis es la siguiente: 

IF condicion THEN
secuencia_de_instrucciones;
ELSIF condicion2 THEN
secuencia_de_instrucciones;
ELSE
secuencia_de_instrucciones;
END IF;

Ejemplo:
BEGIN
...
IF ventas > 50000 THEN
bonus := 1500;
ELSIF ventas > 35000 THEN
bonus := 500;
ELSE
bonus := 100;
END IF;
INSERT INTO payroll VALUES (emp_id,bonus,...);
END;

CASE 
Al igual que IF, la sentencia CASE selecciona una secuencia de sentencias a ejecutar, sin embargo, para realizar la seleccion utiliza un selector y no una expresión booleana. Para ver la diferencia entre IF y CASE presentamos el mismo ejemplo con las dos sintaxis. Con IF tenemos el siguiente codigo:

IF grade = 'A' THEN
	DBMS_OUTPUT.PUT_LINE('Excellent');
ELSIF grade = 'B' THEN
	DBMS_OUTPUT.PUT_LINE('Very Good');
ELSIF grade = 'C' THEN
	DBMS_OUTPUT.PUT_LINE('Good');
ELSIF grade = 'D' THEN
	DBMS_OUTPUT.PUT_LINE('Fair');
ELSIF grade = 'F' THEN
	DBMS_OUTPUT.PUT_LINE('Poor');
ELSE
	DBMS_OUTPUT.PUT_LINE('No such grade');
END IF;

Con CASE tenemos el siguiente codigo:

CASE grade 
	WHEN 'A' THEN DBMS_OUTPUT.PUT_LINE('Excellent');
	WHEN 'B' THEN DBMS_OUTPUT.PUT_LINE('Very Good');
	WHEN 'C' THEN DBMS_OUTPUT.PUT_LINE('Good');
	WHEN 'D' THEN DBMS_OUTPUT.PUT_LINE('Fair');
	WHEN 'F' THEN DBMS_OUTPUT.PUT_LINE('Poor');
	ELSE DBMS_OUTPUT.PUT_LINE('No such grade');
END CASE;

Ejemplo acondicionado a bloques

DECLARE 
	v_Numeroasientos aulas.numeroasientos%TYPE;
	v_Comentario VARCHAR2(35);
BEGIN
/*Recupera el número de asientos del aula con  ID 99999 y almacena el resultado en v_Numeroasientos.*/
	SELECT numeroasientos 
	INTO v_Numeroasientos
	FROM aulas
	WHERE idaula = 99999;
	IF v_Numeroasientos < 50 THEN
		v_Comentario := 'Bastante pequeña';
	ELSIF v_Numeroasientos < 100 THEN
		v_Comentario := 'Grande';
	ELSE 
		v_Comentario := 'Muy Grande';
	END IF;
END;
/

/*---------------------------------------------------------------------------------------*/

Bucles 
PL/SQL utiliza los bucles para ejecutar órdenes de forma repetida

Bucles simples
Los bucles simples tienen la siguiente sintaxis:
LOOP
secuencia_de_instrucciones;
EXIT [WHEN condicion];
END LOOP;

La sintaxix EXIT[WHEN condicion] es equivalente a :
IF condicion THEN 
EXIT;
END IF;

Por lo tanto, la sintaxis completa del bucle simple es la siguiente:

LOOP
secuencia_de_instrucciones;
IF condicion THEN
EXIT;
END IF;
END LOOP;

Ejemplo

DECLARE
v_Contador BINARY_INTEGER := 1;
BEGIN
LOOP
--Inserte una fila e la tabla temporal con el valor actual
--del contador del bucle.
INSERT INTO temporal
VALUES (v_Contador, 'Indice del bucle');
v_Contador := v_Contador + 1;
--Se sale del bucle si su contador super el valor 50
IF v_Contador > 50 THEN
EXIT;
END IF;
END LOOP;
END;
/

DECLARE
v_Contador BINARY_INTEGER := 1;
BEGIN
LOOP
--Inserte una fila e la tabla temporal con el valor actual
--del contador del bucle.
INSERT INTO temporal
VALUES (v_Contador, 'Indice del bucle');
v_Contador := v_Contador + 1;
--Se sale del bucle si su contador super el valor 50
EXIT WHEN v_Contador >50;
END IF;
END LOOP;
END;
/

Bucles WHILE
La sintaxis de un bucle WHILEes la siguiente:
WHILE condicion LOOP
secuencia_de_instrucciones
END LOOP;

Se produce una evaluación de la condicion previa  a cada iteracion del bucle. Si la condicion es verdadera, se ejecuta la secuencia de ordenes, pero si es falsa, el bucle termina y se transfiere el control a las instrucciones posteriores a END LOOP. A continuación, se presenta un ejemplo de bucle WHILE que comprueba el contador del bucle antes de cada iteracion para asegurar que es menor a 50. Si este hecho ocurre, se inserta una fila en la tabla temporal con el valor actual del contador del bucle y se sale del bucle cuando su contador super el balor 50.

DECLARE 
v_Contador BINARY_INTEGER := 1;
BEGIN
--Comprueba el contador del bucle antes de cada iteracion
--para asegurar que es menor que 50.
WHILE v_Contador <= 50 LOOP
INSERT INTO temporal 
VALUES (v_Contador, 'indice del bucle');
v_Contador := v_Contador + 1;
END LOOP;
END;
/
Tambien se pueden utilizar las ordenes EXIT y EXIT WHEN dentro de un bucle WHILE para salir del bucle de forma prematura. La sintaxis sera:

Bucles FOR numericos
Los bucles FOR numericos disponen de un numero de iteraciones definido. Ya hemos visto que en los bucles simples y WHILE el numero de iteraciones depende de la condicion del bucle y no se conoce de antemano. La sintaxis es la siguiente:
FOR contador IN [REVERSE] limite_inferior..limite_superior
LOOP
secuencia_de_instrucciones
END LOOP;
El contador del bucle se declara de modo explicito, el limite inferior y el limite superior acotan el numero de iteraciones (solo se declaran una vez) y la secuencia de ordenes es el contenido del bucle. A continuacion, se presenta un ejemplo:
DECLARE 
v_Contador NUMBER := 7;
--Inserta el valor 7 en la tabla temporal.
INSERT INTO temporal (columnanumerica)
VALUES (v_Contador);
--Este bucle redeclara v_Contador con BINARY_INTEGER,
--lo que anula la declaracion NUMBER de v_Contador
FOR v_Contador IN 20..30 LOOP
--El rango de v_Contador dentro del bucle es de 20 a 30
INSERT INTO temporal (columnanumerica)
VALUES (v_Contadoor);
END LOOP;
--Insertar 7 en la tabla temporal otra vez
INSERT INTO temporal (columnanumerica)
values(v_Contador);
END;
/

Ordenes GOTO y etiquetas
PL/SQL dispone de la orden de salto GO TO. Para identificar el lugar al que se tiene que realizar el salto, se utiliza una etiqueta que suele encerrarse entre corchetes angulares dobles. La sintaxis es la siguiente:
GO TO etiqueta;

Ejemplo:
...
GOTO insertar_fila
<<insertar_fila>>
INSERT INTO emp VALUES...
END;

Ejemplos con bloques 
DECLARE v_Contador BINARY_INTEGER := 1;
BEGIN
LOOP
INSERT INTO temporal
VALUES (v_Contador,'Contador Bucle');
v_Contador = v_Contador +1;
IF v_Contador > 50 THEN
GOTO 1_FinDeBucle;
END IF;
END LOOP;

<<1_FinDeBucle>>
INSERT INTO temporal (columnacaracter)
VALUES('Hecho!');
END;
/

Orden NULL
La orden NULL se utiliza dentro de los programas PL/SQL para indicar que no se realice ninguna acción. A continuacion, se presenta un ejemplo en el que cuando no se cumple la condicion de IF no se realiza ninguna accion.

IF rating > 90 THEN
compute_bonus(emp_id);
ELSE
NULL;
END IF;

Ejemplo:

DECLARE V_Tempvar NUMBER := 7;
BEGIN
IF v_TempVar < 5 THEN
INSERT INTO temporal (columnacaracter)
values('Demasiado pequeño');
ELSIF v_TempVar < 10 THEN
INSERT INTO temporal (columnacaracter)
VALUES ('Justo a la derecha');
ELSE
NULL; --No se ejecuta ninguna accion
END IF;
END;
/


/*---------------------------------------------------------------------------------------*/

Registros, Tablas y Matrices

El paquete estandar PL/SQL tiene predefinidos los tipos escalares, sin embargo, los tipos compuestos deben ser definidos por el usuario antes de ser asignados a alguna variable. Los registros, junto con las tablas, forman tipos compuestos de PL/SQL. Los registros proporcionan un mecanismo para tratar con variables distintas que esten relacionadas entre si, para tratarlas como una unidad. Un registro es una estructura de datos en PL/SQL, almacenados en campos, cada uno de los cuales tiene su propio nombre y tipo y que se tratan como una sola unidad logica. Los registros de PL/SQL son similares a las estructuras del lenguaje C.
La sintaxis general para definir un tipo de registro es el siguiente:

TYPE tipo_registro IS RECORD(
Campo1 tipo1 [NOT NULL] [:=expr1],
Campo2 tipo2 [NOT NULL] [:=expr2],
Campon tipon [NOT NULL] [:=exprn]);

El nombre del nuevo registro tipo_registro y los nombres de los campos que lo componen son campo1, campo2, ..., campon.Los posibles valores iniciales de los campos son expr1, expr2, ..., exprn. Cada declaracion de campo se asemeja a una declaracion de variable.

Ejemplo:

TYPE t_RegistroEstudiante IS RECORD (
ID NUMBER(5),
Nombre VARCHAR(20),
Apellido VARCHAR(20)
);

DECLARE 
TYPE TimeRec IS RECORD (
seconds SMALLINT,
minutes SMALLINT,
hours SMALLINT);
TYPE FlightRec IS RECORD(
flight_no INTEGER,
plane_id VARCHAR2(10),
airport_code VARCHAR2(10));

Utilización de %TYPE y %ROWTYPE

%TYPE se utiliza para definir una variable con el mismo tipo que una columna de la base de datos. De igual forma, %ROWTYPE se utiliza para definir un registro con el mismo tipo que una fila de la base de datos.

Se define un registro utilizando %TYPE
DECLARE 
TYPE DeptRec IS RECORD(
dept_id dept.deptno%TYPE,
dept_name VARCHAR2(15),
dept_loc VARCHAR2(15));
Luego se usa %ROWTYPE para definir un registro cuyos campos se corresponderian con las columnas de la tabla DEPT
DECLARE
DeptRecl %ROWTYPE

/*---------------------------------------------------------------------------------------*/

Cursores 
Dentro de PL/SQL la orden SELECT no debe devolver mas de una fila. Si es necesario que select devuelva mas de una fila, hay que emplear un cursor explicito para extraer individualmente cada fila.

Cursores explicitos 
Un cursor explicito se declara mediante la sintaxis siguiente:

CURSOR nombre_cursor IS orden_SELECT

El cursor explicito se abre mediante la siguiente sintaxis:
OPEN nombre cursor

La extraccion de los datos y su recogida en variables PL/SQL se realiza mediante la siguiente sintaxis:

FETCH nombre_cursor INTO lista_variables;
FETCH nombre_cursor INTO registro_PL/SQL;

La sintaxis nombre_cursor identifica un cursor previamente declarado y abierto, lista_variables es una lidas de variables PL/SQL previamente declaradas y separadas por comas y registro_PL/SQL es un registro PL/SQL previamente declarado.

El cierre de un cursor explicito se realiza mediante la sintaxis:

CLOSE nombre_cursor

Entre los atributos de los cursores tenemos %FOUND y %NOTFOUND para controlar si la ultima orden FETCH devolvió o no una fila, %ISOPEN para ver si el cursor esta o no abierto y %ROWCOUNT que devuelve el numero de filas extraidas por el cursor hasta ahora.

Tambien existe un tipo de cursor que admite parametros como argumentos al estilo de los procedimientos de los lenguajes de programacion procedimentales. Este tipo de cursores se denomina cursores parametrizados.

En el ejemplo se presenta un bucle de extraccion mediante cursor explicito en el que una consulta devuelve multiples filas de datos.

DECLARE 
/*Variables de salida para almacenar los resultados de la consulta*/
v_EstudianteID estudiantes.id%TYPE;
v_Nombre estudiantes.nombre%TYPE;
v_Apellido estudiantes.apellido%TYPE;
/*Variable de acoplamiento usada en la consulta*/
v_Especialidad estudiantes.especialidad%TYPE := 'Computer Science';
/*Declaracion del cursor*/
Cursor c_Estudiantes IS
SELECT id, nombre, apellido FROM estudiantes WHERE especialidad = v_Especialidad;
BEGIN
/*Identificar filas y preparar el procesamiento */
OPEN c_Estudiantes;
LOOP
/*Recuperar cada fila del conjunto activo y almacenarlas en variables PL/SQL*/
FECTH c_Estudiantes INTO v_EstudianteID,v_Nombre,v_Apellido;
/*Si no hya mas filas que recuperar, salir del bucle*/
EXIT WHEN c_Estuddiantes%NOTFOUND;
END LOOP;
/*Liberar los recursores utilizados por la consola*/
CLOSE c_Estudiantes;
END;
/


/*---------------------------------------------------------------------------------------*/

Subprogramas: Procedimientos, funciones, paquetes y disparadores.


Hasta ahora hemos estudiado bloques anónimos que se compilan cada vez que son ejecutados , que no se almacenan en la base de datos y que no pueden ser llamados directamente desde otros bloques PL/SQL. Pero existen otros bloques denominados bloques nominados que no tienen estas restricciones y que pueden ser almacenados en la base de datos para ser ejecutador posteriormente. Entre los bloques nominados son destacableslos procedimientos, las funciones, los paquetes y los disparadores. Los procedimientos y las funciones se denominan subprogramas.

Procedimiento almacenado:
Para crear un procedimiento almacenado se usa la sintaxis general siguiente:

CREATE [OR REPLACE] PROCEDURE nombre_procedimiento
[(argumento [{IN|OUT|IN OUT}] tipo,
...
(argumento [{IN|OUT|IN OUT}] tipo)] {IS|AS}
cuerpo_procedimiento

El nombre del procedimiento es nombre_procedimiento, agumento es el nombre de un parametro del procedimiento, tipo es el tipo de parametro asociado y cuerpo_procedimiento es el bloque PL/SQL que contiene el codigo del procedimiento.
La clausula OR REPLACE da un mensaje de aviso si se va a crear un procedimiento que ya existe. Para cambar el codigo de un procedimiento es necesario eliminarlo y volver a crearlo. Los procedimientos pueden tener parametros reales (contienen los valores que se pasan al procedimientocuando éste es invocado y reciben los resultados del procedimiento cuando este termina) y parametros formales(meros contenedores para los valores de los parametros reales).

Cuando se llama al procedimiento (con CALL) se asigna el valor de los parametros realos a los parametros formales, dentro del procedimiento se hace referecia a dischos valores mediante los parametros formales y cuando el procedimiento termine se asigna el valor de los parametros formales a los parametros reales.

Los parametros formales pueden tener los modos IN(por defecto), OUT o IN OUT. El modo IN indica que el parametro real se pasa al procedimiento cuando este es invocado, dentro del procedimiento el parametro formal se considera como de solo lectura(no puede ser cambiado) y cuando termina el procedimiento el parametro real no sufre cambios. El modo OUT indica que se ignora cualquier valor que tenga el parametro real cuando se llama al procedimiento, dentro del procedimiento el parametro real se considera como de solo escritura(no puede ser leido pero si es posible asignarle valores) y cuando finaliza el procedimiento los contenidos del parametro formal pasan al parametro real. El modo IN OUT indica que el parametro real se pasa al procedimiento cuando este es invocado, dentro del procedimiento el parametro formal puede ser de lectura y escritura, y cuando el procedimiento termina, los contenidos del parametro formal se asignal al parametro real.

El cuerpo de un procedimiento es un bloque PL/SQL con sus secciones declarativa, ejecutable, y de manejo de excepciones. La seccion declarativa se situa entre las palabras clave IS o AS y la palabra clave BEGIN, la ejecutable entre BEGIN y EXCEPTION y la de excepciones entre EXCEPTION y END(no existe la palabra clave DECLARE en un procedimiento y su lugar lo ocupan IS o AS). A veces, se suele incluir el nombre del propio procedimiento despes de la orden END que cierra la declaración.
Los parametros formales de un procedimiento pueden tener valores predeterminados que se declaran mediante la siguiente sintaxis:

nombre_parametro[modo] tipo_parametro{:=\DEFAULT} valor inicial

Ejemplo

CREATE OR REPLAE PROCEDURE AñadeNuevoEstudiante(
p_Nombre estudiantes.nombre%TYPE,
p_Apellido estudiantes.apellido%TYPE,
p_Especialidad estudiantes.especialidad%TYPE) AS
BEGIN
--Inserta una nueva fila en la tabla estudiantes,
--Usa secuencia para generar un nuevo ID de estudiante y
--Asigna el valor cero a creditos
INSERT INTO estudiantes (ID, nombre, apellido, especialidad, creditos) 
VALUES(secuencia.netxval,p_Nnmbre, p_Apellido, p_Especialidad, 0);
COMMIT;
END AñadeNuevoEstudiante;
/

Para invocar se usa: 
SET SERVEROUTPUT ON;
EXCECUTE AñadeNuevoEstudiante(parametro1,parametro2,parametro3);

o

BEGIN
AñadeNuevoEstudiante(parametro1,parametro2,parametro3);
END;
/

Tambien pueden definirse en el bloque PL/SQL parametros reales para pasar al procedimiento tal y como se observa en el sig ejemplo:
DECLARE
--Variables que describen al nuevo estudiantes
v_NuevoNombre estudiantes.nombre%TYPE := 'Margaret';
v_NuevoApellido estudiantes.apellido%TYPE := 'Mason';
v_NuevaEspecialidad estudiantes.especialidad%TYPE := 'History';
BEGIN
--Añadir margaret mason a la base de datos
AñadeNueboEstudiante(v_NuevoNombre,v_NuevoApellido,v_NuevaEspecialidad);
END;
/

Ejemplo sobre IN, OUT e IN OUT

CREATE OR REPLACE PROCEDURE ModeTest(
p_InParameter IN NUMBER,
p_OutParameter OUT NUMBER,
p_InOutParameter IN OUT NUMBER) IS
v_LocalVariable NUMBER;
BEGIN
/*Asigna p_InParameter a v_LocalVariable.Esto es legal, porque leemos desde un parametro IN y no se escribe en el*/
v_LocalVariable:=p_InParameter; --Legal

/*Asigna 7 a p_OutParameter. Esto es lega, ya que se escribe en un parametro OUT y no se lee de el*/
p_OutParameter := 7; --Legal

/*Agina p_InOutParameter a v_LocalVariable.Esto es legar, ya que se lee de un parametro IN OUT*/
v_LovalVariable:= p_InOutParameter; --Legal

/*Asigna 7 a p_InOutParameter.Esto es legal, ya que se lee de un parametro IN OUT*/
p_InOutParameter:=7; --Legal
END ModeTest;
/
