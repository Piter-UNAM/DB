Guía de PL/SQL

/*---------------------------------------------------------------------------------------*/
PL/SQL SE COMPONE DE LOS SIGUIENTES ELEMENTOS:
Bloques: Unidades básicas en la programación PL/SQL
Unidades léxicas: secuencias de caracteres permitidos en PL/SQL que componen los programas.
Tipos: elementos que pueden usarse en las columnas de la base de datos y definen la naturaleza de los datos permitidos en la base de datos y en el lenguaje PL/SQL. Los tipos de PL/SQL se definen en un paquete denominado STANDAR cuyos contenidos son accesibles desde cualquier bloque PL/SQL.
Expresiones y operadores: elementos que permiten unir las variables PL/SQL. Los operadores definen cómo se asignan los valores a las variables y cómo se manipulan dichos valores. Una expresión es una secuencia de variables y literales separados por operadores. El valor de una expresión se determina a partir de los valores de las variables y literales que la componen, y de la definición de los operadores.
Funciones: además de los tipos, el paquete STANDARD define las funciones predefinidas SQL y de conversión disponibles en PL/SQL.
Estructuras de control PL/SQL: permiten controlar el comportamiento del bloque a medida que este se ejecuta e incluyen las órdenes condicionales y los bucles. Las estructuras de control combinadas con las variables dotan a PL/SQL de poder y flexibilidad.
Registros: los registros de PL/SQL son similares a las estructuras del lenguaje C. Un registro proporciona un mecanismo para tratar con variables diferentes, pero relacionadas, como si fueran una unidad.
Tablas y matrices: las tablas PL/SQL se asemejan a las matrices del lenguaje C. Sintácticamente se las trata de la misma forma que a las matrices, aunque su implementación es distinta. Para poder declarar una tabla en PL/SQL es necesario primero definir su tipo y luego una variable de dicho tipo.
Cursores: dentro de PL/SQL la orden SELECT no debe devolver más de una fila, pero si es necesario que SELECT devuelva más de una fila hay que emplear un cursor para extraer individualmente cada fila.
Procedimientos: estructuras de bloques que pueden ser almacenados en la base de datos para ser ejecutados cuando sea necesario.
Paquetes: estructuras de bloques PL/SQL que proporcionan un mecanismo para extender en todo momento el propio lenguaje PL/SQL.
Disparadores: estructuras de bloques que se ejecutan de forma implícita cada vez que tiene lugar el suceso de disparo. Los disparadores no admiten argumentos.

/*---------------------------------------------------------------------------------------*/

Bloques PL/SQL
Los programas de PL/SQL están compuestos por bloques, que pueden estar situados uno detrás de otro(estructura secuencial) o pueden estar uno dentro de otro(estructura anidada). Por tanto, el bloque es la unidad básica en PL/SQL.

Los bloques tienen tres secciones diferenciadas:

-Sección declarativa: se sitúan en ella las variables, cursores y tipos usados por el bloque
-Sección ejecutables: se sitúan en ellas las órdenes SQL y las órdenes procedimentales que llevan a cabo el trabajo del bloque.
-Sección de excepciones: se sitúa en ella código que no se ejecuta a menos que ocurra un error. Por esta razón, la sección de excepciones suele llamase también sección de tratamiento de errores

La sintaxis de un programa PL/SQL será la siguiente:

DECLARE
/*Sección declarativa*/
BEGIN
/*Sección ejecutable*/
EXCEPTION
/*Sección de excepciones*/
NED;
/

Cuando se trabaja en el ambiente SQL*PLUS es necesario acabar los programas con una barra inclinada (/).
Las palabras DECLARE,BEGIN,EXCEPTION Y END delimitan cada una de las secciones.

La única sección indispensable en un bloque es la sección ejecutable, siendo las otras dos opcionales. Si falta la sección de excepciones, no aparecerá la palabra clave EXCEPTION, y el bloque terminará con la palabra clave END, seguida de un punto y coma. Por tanto, un programa mínimo, es decir, un programa PL/SQL con sólo la sección ejecutable, tiene la siguiente estructura:

BEGIN
/*Sección ejecutable*/
END;
/

/*---------------------------------------------------------------------------------------*/

Creación de base de datos para trabajar los futuros ejemplos:

CREATE TABLE clientes(
Num_clie integer not null PRIMARY KEY,
Empresa char(20) not null,
Repclie integer,
Limite_credito numeric
);

CREATE TABLE repventas(
Num_empl integer not null PRIMARY KEY,
Nombre char(15) not null,
Edad integer,
Oficina_rep integer,
Titulo char(10),
Contrato date not null,
Director integer,
Cuota numeric,
Ventas numeric not null
);

CREATE TABLE oficinas(
Oficina integer not null PRIMARY KEY,
Ciudad char(15) not null,
Region char(10) not null,
Dir integer REFERENCES repventas (Num_empl),
Objetivo number,
Ventas number not null
);

CREATE TABLE productos(
Id_fab char(3) not null,
Id_producto char(5) not null,
Descripción char(20) not null,
Precio number not null,
Existencias integer not null,
CONSTRAINT productos_Id_fab_Id_producto 
PRIMARY KEY (Id_fab, Id_producto)
);

CREATE TABLE pedidos (
Num_pedido integer not null PRIMARY KEY,
Fecha date not null,
Clie integer not null REFERENCES clientes (Num_clie),
Rep integer REFERENCES repventas (Num_empl),
Fab char(3) not null,
Producto char(5) not null,
Cant integer not null,
Importe number not null
);

Datos para insertar en las distintas tablas anteriormente creadas

INSERT INTO clientes VALUES (2101,'Jones Mfg.',106,65000);
INSERT INTO clientes VALUES (2102,'First. Corp.',101,65000);
INSERT INTO clientes VALUES (2103,'Acme Mfg.',105,50000);
INSERT INTO clientes VALUES (2105,'AAA Investments',101,45000);
INSERT INTO clientes VALUES (2106,'Fred Lewis Crop.',102,65000);
INSERT INTO clientes VALUES (2107,'Ace International',110,35000);
INSERT INTO clientes VALUES (2108,'Holm Landis',109,55000);
INSERT INTO clientes VALUES (2109,'Chen associates',103,25000);
INSERT INTO clientes VALUES (2111,'JCP Inc.',103,50000);
INSERT INTO clientes VALUES (2112,'Zetacorp',108,50000);
INSERT INTO clientes VALUES (2113,'Ian Schmidt',104,20000);
INSERT INTO clientes VALUES (2114,'Orion Corp',102,20000);
INSERT INTO clientes VALUES (2115,'Smithson Corp',101,20000);
INSERT INTO clientes VALUES (2117,'J.P. Sinclair',106,35000);
INSERT INTO clientes VALUES (2118,'Midwest Systems',108,60000);
INSERT INTO clientes VALUES (2119,'Solomon INC. ',109,25000);
INSERT INTO clientes VALUES (2120,'Rico Enterprises',102,50000);
INSERT INTO clientes VALUES (2121,'QMA Assoc',103,45000);
INSERT INTO clientes VALUES (2122,'Three-Way Lines',105,30000);
INSERT INTO clientes VALUES (2123,'Carter Sons',102,40000);
INSERT INTO clientes VALUES (2124,'Peter Brothers',107,40000);

INSERT INTO repventas VALUES(101,'Dan Roberts',45,12,'Rep Ventas','20-10-1986',104,300000,305673);
INSERT INTO repventas VALUES(102,'Sue Smith',48,21,'Rep Ventas','12-12-1986',108,350000,474050);
INSERT INTO repventas VALUES(103,'Paul Cruz',29,12,'Rep Ventas','01-04-1987',104,275000,286775);
INSERT INTO repventas VALUES(104,'Bob Smith',33,12,'Dir Ventas','19-05-1987',106,200000,142594);
INSERT INTO repventas VALUES(105,'Bill Adams',37,13,'Rep Ventas','12-02-1988',104,350000,367911);
INSERT INTO repventas VALUES(106,'Sam Clark',52,11,'VP Ventas','14-06-1988',null,275000,299912);
INSERT INTO repventas VALUES(107,'Nancy Angelli',49,22,'Rep Ventas','14-11-1988',108,300000,186042);
INSERT INTO repventas VALUES(108,'Larry Fitch',62,21,'Dir Ventas','12-10-1989',106,350000,361865);
INSERT INTO repventas VALUES(109,'Mary Jones',31,11,'Rep Ventas','12-10-1999',106,300000,392725);
INSERT INTO repventas VALUES(110,'Tom Snyde',41,null,'Rep Ventas','14-01-1990',101,null,75985);

INSERT INTO oficinas VALUES (11,'New York','Este',106,575000,692637);
INSERT INTO oficinas VALUES (12,'Chicago','Este',104,800000,735042);
INSERT INTO oficinas VALUES (13,'Atlanta','Este',105,350000,367911);
INSERT INTO oficinas VALUES (21,'Los Ángeles','Oeste',108,725000,835915);
INSERT INTO oficinas VALUES (22,'Denver','Oeste',108,300000,186042);

/*---------------------------------------------------------------------------------------*/

Ejemplo de programa PL/SQL sin excepciones:

DECLARE
/*Declaración de las variables a utilizar*/
v_NuevaEspecialidad VARCHAR2(10):='History';
v_Nombre VARCHAR(10):='Scott';
v_Apellido VARCHAR(10):='Urman';
BEGIN
/*Actualización de la tabla ESTUDIANTES*/
UPDATE ESTUDIANTES
SET especialidad = v_NuevaEspecialidad
WHERE nombre = v_Apellido;
/*Comprobación de la existencia del registro antes de insertarlo*/
IF SQL%NOTFOUND THEN
INSERT INTO estudiantes (ID, nombre, apellido, especialidad)
VALUES (secuencia.NEXTVAL, v_Nombre, v_Apellido, v_NuevaEspecialidad);
END IF;
END;
/
